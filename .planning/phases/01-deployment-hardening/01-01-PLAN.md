---
phase: 01-deployment-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/config.py
  - src/core/models.py
autonomous: true
requirements:
  - DEPLOY-01

must_haves:
  truths:
    - "The application database file is always created at /app/data/ke_wp_mapping.db (never a relative path) when running in production"
    - "Every SQLite connection opens with WAL journal mode, NORMAL synchronous, and a 5-second busy timeout"
    - "Multiple concurrent writes do not raise 'database is locked' errors — SQLite waits up to 5 seconds before failing"
  artifacts:
    - path: "src/core/config.py"
      provides: "DATABASE_PATH default changed to /app/data/ke_wp_mapping.db"
      contains: "/app/data/ke_wp_mapping.db"
    - path: "src/core/models.py"
      provides: "WAL PRAGMA applied on every get_connection() call"
      contains: "PRAGMA journal_mode=WAL"
  key_links:
    - from: "src/core/config.py"
      to: "src/services/container.py"
      via: "Database(self.config.DATABASE_PATH)"
      pattern: "DATABASE_PATH.*=.*os\\.getenv"
    - from: "src/core/models.py"
      to: "sqlite3.connect"
      via: "get_connection() PRAGMA execution"
      pattern: "PRAGMA journal_mode=WAL"
---

<objective>
Fix the database path default and enable SQLite WAL mode for concurrent curator access.

Purpose: The database currently defaults to a relative path `ke_wp_mapping.db` that becomes unreachable inside a Docker container. Concurrent curator writes will also cause `database is locked` errors without WAL mode. Both must be fixed before any external user submits data.

Output: `src/core/config.py` with corrected DATABASE_PATH; `src/core/models.py` with WAL + busy_timeout PRAGMAs on every connection.
</objective>

<execution_context>
@/home/marvin/.claude/get-shit-done/workflows/execute-plan.md
@/home/marvin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-deployment-hardening/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix DATABASE_PATH default to Docker-safe absolute path</name>
  <files>src/core/config.py</files>
  <action>
    In `src/core/config.py`, change line 34 from:

    ```python
    DATABASE_PATH = os.getenv("DATABASE_PATH", "ke_wp_mapping.db")
    ```

    to:

    ```python
    DATABASE_PATH = os.getenv("DATABASE_PATH", "/app/data/ke_wp_mapping.db")
    ```

    Also change line 33 (DATABASE_URL) from:

    ```python
    DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///ke_wp_mapping.db")
    ```

    to:

    ```python
    DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:////app/data/ke_wp_mapping.db")
    ```

    Note: TestingConfig at line 97 already overrides DATABASE_PATH to ":memory:" — do NOT change that line. The base Config class change is all that is needed.

    The locked decision from CONTEXT.md requires `/app/data/ke_wp_mapping.db` as the firm path. This is the database path that will be mounted as a Docker volume from the host. Without this fix, the container creates the database inside the image layer and loses data on container recreation.
  </action>
  <verify>
    Run: `python -c "import os; os.environ['FLASK_ENV']='production'; os.environ['FLASK_SECRET_KEY']='x'; os.environ['GITHUB_CLIENT_ID']='x'; os.environ['GITHUB_CLIENT_SECRET']='x'; from src.core.config import Config; c=Config(); print(c.DATABASE_PATH)"`

    Expected output: `/app/data/ke_wp_mapping.db`

    Also verify TestingConfig is unchanged:
    `python -c "from src.core.config import TestingConfig; c=TestingConfig(); print(c.DATABASE_PATH)"`
    Expected: `:memory:`
  </verify>
  <done>Config.DATABASE_PATH defaults to `/app/data/ke_wp_mapping.db`; TestingConfig still uses `:memory:`; no test breakage.</done>
</task>

<task type="auto">
  <name>Task 2: Enable WAL mode and busy timeout on every SQLite connection</name>
  <files>src/core/models.py</files>
  <action>
    In `src/core/models.py`, replace the `get_connection()` method (lines 18–21 currently):

    ```python
    def get_connection(self):
        """Get database connection with row factory for dict-like access"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        return conn
    ```

    with:

    ```python
    def get_connection(self):
        """Get database connection with WAL mode, busy timeout, and row factory."""
        conn = sqlite3.connect(self.db_path, timeout=30)
        conn.row_factory = sqlite3.Row
        conn.execute("PRAGMA journal_mode=WAL;")
        conn.execute("PRAGMA synchronous=NORMAL;")
        conn.execute("PRAGMA busy_timeout=5000;")
        return conn
    ```

    Rationale:
    - `timeout=30`: Python-level retry before raising OperationalError (30s fallback).
    - `PRAGMA journal_mode=WAL`: Enables Write-Ahead Logging for concurrent reads during writes. Idempotent — safe to set on every connection even if already WAL mode.
    - `PRAGMA synchronous=NORMAL`: Good durability/performance balance in WAL mode (vs FULL which syncs on every write).
    - `PRAGMA busy_timeout=5000`: SQLite-level wait up to 5 seconds when another writer holds the lock, instead of immediately raising "database is locked". Set in milliseconds.

    This is the single chokepoint for all database access — every model class calls `self.db.get_connection()`. No other files need to change for WAL mode.
  </action>
  <verify>
    Run: `python -c "
    import sqlite3, tempfile, os
    from src.core.models import Database
    with tempfile.NamedTemporaryFile(suffix='.db', delete=False) as f:
        db_path = f.name
    db = Database(db_path)
    conn = db.get_connection()
    result = conn.execute('PRAGMA journal_mode;').fetchone()[0]
    print('WAL mode:', result)
    bt = conn.execute('PRAGMA busy_timeout;').fetchone()[0]
    print('Busy timeout (ms):', bt)
    conn.close()
    os.unlink(db_path)
    "`

    Expected output:
    ```
    WAL mode: wal
    Busy timeout (ms): 5000
    ```
  </verify>
  <done>Every connection returned by `Database.get_connection()` has WAL mode enabled and busy_timeout=5000ms; confirmed by PRAGMA query.</done>
</task>

</tasks>

<verification>
After both tasks complete, run the existing test suite to confirm no regressions:

```bash
cd /home/marvin/Documents/Services/Ke-gene-mapping/KE-WP-mapping && python -m pytest tests/ -x -q 2>&1 | head -40
```

Tests use TestingConfig which sets `DATABASE_PATH = ":memory:"` — the WAL PRAGMA on an in-memory database is a no-op, so tests should pass unchanged.
</verification>

<success_criteria>
- `Config.DATABASE_PATH` defaults to `/app/data/ke_wp_mapping.db` (not a relative path)
- `TestingConfig.DATABASE_PATH` remains `:memory:` (tests unaffected)
- `Database.get_connection()` applies `PRAGMA journal_mode=WAL`, `PRAGMA synchronous=NORMAL`, and `PRAGMA busy_timeout=5000` on every new connection
- Existing test suite passes without modification
</success_criteria>

<output>
After completion, create `.planning/phases/01-deployment-hardening/01-01-SUMMARY.md` with:
- What was changed and why
- Any unexpected findings
- Verification results
</output>

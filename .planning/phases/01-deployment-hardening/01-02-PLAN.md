---
phase: 01-deployment-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - docker-compose.yml
  - Dockerfile
  - gunicorn.conf.py
  - scripts/backup_db.sh
  - scripts/docker-entrypoint.sh
autonomous: true
requirements:
  - DEPLOY-03

must_haves:
  truths:
    - "The Docker container starts without errors — no missing nginx.conf, no missing redis service dependency"
    - "Gunicorn loads its configuration from gunicorn.conf.py with preload_app=True (model loads once in master, workers inherit)"
    - "A daily cron job inside the container runs sqlite3 .backup and writes backups to /app/data/backups/"
    - "Environment secrets are loaded from the host .env file via env_file directive, not hardcoded in docker-compose.yml"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Cleaned compose file with env_file directive and no dead redis/nginx services"
      contains: "env_file"
    - path: "Dockerfile"
      provides: "Cron installed, entrypoint script added, CMD uses gunicorn.conf.py"
      contains: "gunicorn.conf.py"
    - path: "gunicorn.conf.py"
      provides: "Version-controlled Gunicorn config with preload_app=True and 2 workers"
      contains: "preload_app = True"
    - path: "scripts/backup_db.sh"
      provides: "Backup script using sqlite3 Online Backup API with integrity check and 7-day retention"
      contains: "sqlite3.*\\.backup"
    - path: "scripts/docker-entrypoint.sh"
      provides: "Container entrypoint that starts cron then exec gunicorn"
      contains: "cron"
  key_links:
    - from: "Dockerfile"
      to: "scripts/docker-entrypoint.sh"
      via: "ENTRYPOINT directive"
      pattern: "ENTRYPOINT.*entrypoint"
    - from: "scripts/docker-entrypoint.sh"
      to: "gunicorn.conf.py"
      via: "exec gunicorn -c gunicorn.conf.py"
      pattern: "gunicorn.*gunicorn\\.conf\\.py"
    - from: "Dockerfile"
      to: "scripts/backup_db.sh"
      via: "COPY and crontab installation"
      pattern: "backup_db\\.sh"
---

<objective>
Harden the Docker deployment configuration: clean up dead services in docker-compose.yml, create a version-controlled gunicorn.conf.py with preload_app=True, add a container-internal cron backup job using sqlite3's Online Backup API, and wire everything together with a Docker entrypoint script.

Purpose: The current docker-compose.yml references nginx (no nginx.conf exists) and redis (not used by codebase), which prevents the container from starting. Gunicorn config is inline in Dockerfile CMD making it unversioned and untunable. Backups do not exist yet — required before external curator data is submitted (DEPLOY-03).

Output: Working docker-compose.yml; gunicorn.conf.py; scripts/backup_db.sh; scripts/docker-entrypoint.sh; updated Dockerfile.
</objective>

<execution_context>
@/home/marvin/.claude/get-shit-done/workflows/execute-plan.md
@/home/marvin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-deployment-hardening/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix docker-compose.yml and create gunicorn.conf.py</name>
  <files>docker-compose.yml, gunicorn.conf.py</files>
  <action>
    **docker-compose.yml** — Replace the entire file with a corrected version that:
    1. Removes the `redis` service block (codebase uses `memory://` rate limiting, not Redis)
    2. Removes the `nginx` service block (no nginx.conf exists in the repo; causes startup failure)
    3. Removes `volumes: redis_data:` (no longer needed)
    4. Removes `depends_on: redis` from the `web` service
    5. Replaces the `environment:` block with `env_file: .env` (locked decision from CONTEXT.md)
    6. Adds a `backups` volume mount: `- ./backups:/app/data/backups` for backup persistence

    Final docker-compose.yml:
    ```yaml
    version: '3.8'

    services:
      web:
        build: .
        ports:
          - "5000:5000"
        env_file:
          - .env
        volumes:
          - ./data:/app/data
          - ./logs:/app/logs
          - ./backups:/app/data/backups
        restart: unless-stopped
        networks:
          - ke-wp-network

    networks:
      ke-wp-network:
        driver: bridge
    ```

    **gunicorn.conf.py** — Create at project root (version-controlled, per locked decision). Start with 2 workers (conservative start per research recommendation — BioBERT ~440MB + embedding arrays ~180MB; 4 workers aspirational but start safe):

    ```python
    # gunicorn.conf.py
    # Gunicorn configuration for KE-WP Mapping application.
    # Source: https://gunicorn.org/reference/settings
    #
    # Worker count: start with 2 (conservative for BioBERT ~440MB model).
    # After deployment, measure with `docker stats ke-wp-mapping-web-1`.
    # Increase to 3 or 4 if total RAM stays under 4GB.

    bind = "0.0.0.0:5000"
    workers = 2          # Each marginal worker adds ~80MB overhead (model shared via fork COW)
    worker_class = "sync"
    timeout = 120        # BioBERT inference can be slow on first request
    keepalive = 5
    preload_app = True   # Load BioBERT model ONCE in master; workers inherit via Linux fork COW.
                         # WARNING: incompatible with --reload; never use --reload in production.
    max_requests = 500   # Restart workers periodically to prevent memory fragmentation
    max_requests_jitter = 50  # Stagger restarts to avoid thundering herd
    accesslog = "/app/logs/access.log"
    errorlog = "/app/logs/error.log"
    loglevel = "info"
    ```
  </action>
  <verify>
    Validate docker-compose.yml is valid YAML with no dead service references:
    ```bash
    python -c "import yaml; data=yaml.safe_load(open('/home/marvin/Documents/Services/Ke-gene-mapping/KE-WP-mapping/docker-compose.yml')); print('Services:', list(data['services'].keys())); print('OK' if 'redis' not in data['services'] and 'nginx' not in data['services'] else 'FAIL - dead services present')"
    ```
    Expected: `Services: ['web']` and `OK`.

    Validate gunicorn.conf.py is valid Python and has preload_app:
    ```bash
    python -c "
    import ast
    src = open('/home/marvin/Documents/Services/Ke-gene-mapping/KE-WP-mapping/gunicorn.conf.py').read()
    ast.parse(src)
    print('Syntax OK')
    assert 'preload_app = True' in src, 'Missing preload_app'
    print('preload_app: True present')
    "
    ```
  </verify>
  <done>docker-compose.yml has only the `web` service with env_file directive; gunicorn.conf.py exists at project root with preload_app=True and workers=2.</done>
</task>

<task type="auto">
  <name>Task 2: Create backup script, entrypoint, and update Dockerfile</name>
  <files>scripts/backup_db.sh, scripts/docker-entrypoint.sh, Dockerfile</files>
  <action>
    **scripts/backup_db.sh** — Create the SQLite backup script using the Online Backup API. This is safe to run during active writes (unlike a file copy). Daily schedule + 7-day retention (Claude's discretion per CONTEXT.md):

    ```bash
    #!/bin/bash
    # /app/scripts/backup_db.sh
    # SQLite backup using Online Backup API (safe during active writes).
    # Schedule: daily at 02:00 container time. Retention: 7 days.
    # Source: https://sqlite.org/backup.html
    set -euo pipefail

    DB_PATH="/app/data/ke_wp_mapping.db"
    BACKUP_DIR="/app/data/backups"
    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    BACKUP_FILE="${BACKUP_DIR}/ke_wp_mapping_${TIMESTAMP}.db"
    RETENTION_DAYS=7

    mkdir -p "${BACKUP_DIR}"

    # .backup uses the Online Backup API: checkpoints WAL, then copies atomically.
    # DO NOT back up just the .db file without the -wal and -shm files;
    # always use this script to get a consistent snapshot.
    sqlite3 "${DB_PATH}" ".backup '${BACKUP_FILE}'"

    # Integrity check — remove backup if corrupted
    RESULT=$(sqlite3 "${BACKUP_FILE}" "PRAGMA integrity_check;")
    if [ "${RESULT}" != "ok" ]; then
        echo "[BACKUP ERROR] Integrity check failed for ${BACKUP_FILE}: ${RESULT}" >&2
        rm -f "${BACKUP_FILE}"
        exit 1
    fi

    echo "[BACKUP OK] ${BACKUP_FILE}"

    # Prune backups older than retention period
    find "${BACKUP_DIR}" -name "ke_wp_mapping_*.db" -mtime "+${RETENTION_DAYS}" -delete
    ```

    **scripts/docker-entrypoint.sh** — Create an entrypoint script that starts cron (for backups) then exec's gunicorn (so gunicorn gets PID 1 signals):

    ```bash
    #!/bin/bash
    # /app/scripts/docker-entrypoint.sh
    # Start cron for scheduled backups, then exec the main process (gunicorn).
    # Using exec ensures gunicorn receives Docker stop signals correctly.
    set -e

    # Start cron daemon in background for backup scheduling
    service cron start || true

    # Hand off to gunicorn (or whatever CMD is passed)
    exec "$@"
    ```

    **Create crontab file** at `scripts/ke-wp-backup` (for COPY into /etc/cron.d/):
    ```
    # KE-WP Mapping database backup — daily at 02:00
    0 2 * * * root /app/scripts/backup_db.sh >> /app/logs/backup.log 2>&1
    ```
    Note: Use `root` as the cron user (since the cron.d format requires a username field and the script runs before USER appuser switch in container PID 1).

    Actually, because the Dockerfile switches to `appuser` but cron.d runs as the specified user — and `appuser` owns `/app` — use `appuser` in the crontab:
    ```
    0 2 * * * appuser /app/scripts/backup_db.sh >> /app/logs/backup.log 2>&1
    ```

    **Dockerfile** — Replace the entire runtime stage section. Key changes:
    1. Add `cron` to the apt-get install line
    2. Copy backup script and make it executable
    3. Copy and install the crontab
    4. Copy the entrypoint script and make it executable
    5. Change CMD from inline gunicorn args to `["gunicorn", "-c", "gunicorn.conf.py", "app:app"]`
    6. Add ENTRYPOINT to the entrypoint script

    Replace the runtime stage (lines 12–25) with:

    ```dockerfile
    # --- Runtime stage ---
    FROM python:3.12-slim-bookworm
    ENV PYTHONDONTWRITEBYTECODE=1 PYTHONUNBUFFERED=1 FLASK_APP=app.py FLASK_ENV=production
    WORKDIR /app
    RUN apt-get update && apt-get install -y --no-install-recommends curl sqlite3 cron \
        && rm -rf /var/lib/apt/lists/*
    COPY --from=builder /install /usr/local
    COPY . .
    RUN adduser --disabled-password --gecos '' appuser && chown -R appuser:appuser /app
    RUN mkdir -p /app/static/css /app/static/js /app/data /app/logs /app/data/backups \
        && chown -R appuser:appuser /app/logs /app/data
    # Install backup crontab
    COPY scripts/ke-wp-backup /etc/cron.d/ke-wp-backup
    RUN chmod 0644 /etc/cron.d/ke-wp-backup
    # Make scripts executable
    RUN chmod +x /app/scripts/backup_db.sh /app/scripts/docker-entrypoint.sh
    USER appuser
    EXPOSE 5000
    HEALTHCHECK --interval=30s --timeout=30s --start-period=60s --retries=3 \
        CMD curl -f http://localhost:5000/health || exit 1
    ENTRYPOINT ["/app/scripts/docker-entrypoint.sh"]
    CMD ["gunicorn", "-c", "gunicorn.conf.py", "app:app"]
    ```

    Note: `start-period` increased to 60s (from 20s) because BioBERT loading with `preload_app=True` takes ~30-40s on first start.
  </action>
  <verify>
    Check all scripts are syntactically valid and have correct permissions markers:
    ```bash
    bash -n /home/marvin/Documents/Services/Ke-gene-mapping/KE-WP-mapping/scripts/backup_db.sh && echo "backup_db.sh: syntax OK"
    bash -n /home/marvin/Documents/Services/Ke-gene-mapping/KE-WP-mapping/scripts/docker-entrypoint.sh && echo "docker-entrypoint.sh: syntax OK"
    head -1 /home/marvin/Documents/Services/Ke-gene-mapping/KE-WP-mapping/scripts/backup_db.sh
    head -1 /home/marvin/Documents/Services/Ke-gene-mapping/KE-WP-mapping/scripts/docker-entrypoint.sh
    ```
    Both scripts must start with `#!/bin/bash`.

    Check Dockerfile has the required elements:
    ```bash
    grep -n "gunicorn.conf.py\|ENTRYPOINT\|cron\|preload" /home/marvin/Documents/Services/Ke-gene-mapping/KE-WP-mapping/Dockerfile
    ```
    Must show: `cron` in apt-get line, ENTRYPOINT referencing docker-entrypoint.sh, CMD referencing gunicorn.conf.py.
  </verify>
  <done>scripts/backup_db.sh and scripts/docker-entrypoint.sh exist with correct shebang and syntax; scripts/ke-wp-backup crontab file exists; Dockerfile installs cron, sets ENTRYPOINT, and CMD uses gunicorn.conf.py.</done>
</task>

</tasks>

<verification>
Verify the complete Docker build chain is coherent:
```bash
cd /home/marvin/Documents/Services/Ke-gene-mapping/KE-WP-mapping
# Check all referenced files exist
ls scripts/backup_db.sh scripts/docker-entrypoint.sh scripts/ke-wp-backup gunicorn.conf.py
# Validate Python syntax of gunicorn.conf.py
python -m py_compile gunicorn.conf.py && echo "gunicorn.conf.py: OK"
# Validate docker-compose has no dead services
python -c "import yaml; d=yaml.safe_load(open('docker-compose.yml')); assert list(d['services'].keys())==['web'], 'Extra services'; print('docker-compose: OK')"
```
</verification>

<success_criteria>
- docker-compose.yml contains only the `web` service with `env_file: .env` and no redis/nginx references
- gunicorn.conf.py exists at project root with `preload_app = True` and `workers = 2`
- scripts/backup_db.sh uses `sqlite3 .backup` with integrity check and 7-day retention
- scripts/docker-entrypoint.sh starts cron then exec's gunicorn
- scripts/ke-wp-backup crontab file schedules daily backup at 02:00
- Dockerfile installs cron, sets ENTRYPOINT to docker-entrypoint.sh, CMD uses gunicorn.conf.py
- HEALTHCHECK start-period increased to 60s for BioBERT load time
</success_criteria>

<output>
After completion, create `.planning/phases/01-deployment-hardening/01-02-SUMMARY.md` with:
- What was changed and why
- Any unexpected findings
- Verification results
</output>
